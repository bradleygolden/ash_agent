# Getting Started with AshAgent

AshAgent is an Ash Framework extension that enables you to build AI agent applications with LLM integration using a declarative DSL.

## Installation

Add `ash_agent` to your list of dependencies in `mix.exs`:

```elixir
def deps do
  [
    {:ash_agent, "~> 0.1.0"}
  ]
end
```

Then run:

```bash
mix deps.get
```

## Quick Start

### 1. Add the Extension to Your Resource

```elixir
defmodule MyApp.Agents.Assistant do
  use Ash.Resource,
    domain: MyApp.Agents,
    extensions: [AshAgent.Resource]

  agent do
    provider :req_llm
    client "anthropic:claude-3-5-sonnet"

    output MyApp.Reply

    prompt ~p"""
    You are a helpful assistant.
    {{ output_format }}
    """
  end

  attributes do
    uuid_primary_key :id
    attribute :name, :string, allow_nil?: false
  end
end
```

### 2. Add the Extension to Your Domain

```elixir
defmodule MyApp.Agents do
  use Ash.Domain,
    extensions: [AshAgent.Domain]

  resources do
    resource MyApp.Agents.Assistant
  end
end
```

### 3. Use the Agent

Declaring an `agent` block automatically generates `:call` and `:stream` actions, so you can invoke it immediately or expose those actions through a `code_interface`.

```elixir
# Synchronous response
{:ok, reply} = MyApp.Agents.Assistant.call(message: "Hello!")

# Streaming responses
MyApp.Agents.Assistant.stream(message: "Hello!")
|> Enum.to_list()
```

## Choosing a Provider

AshAgent separates orchestration from LLM execution. Set `provider` inside your `agent` block (defaults to `:req_llm`):

- `:req_llm` – direct ReqLLM integration; prompt required.
- `:baml` – delegates to ash_baml functions; prompt optional.
- Custom modules – implement `AshAgent.Provider` and register via `config :ash_agent, providers: [...]`.

```elixir
agent do
  provider :baml
  client :support, function: :ChatAgent
  output MyApp.BamlClients.Support.Types.ChatAgent
end
```

Since the BAML provider advertises `:prompt_optional`, you can omit the prompt entirely. Providers lacking that capability (e.g., `:req_llm`) will still enforce a prompt at compile time.

## Tool Calling

Agents can use tools to interact with external systems, call Ash actions, or execute Elixir functions during multi-turn conversations. When tools are defined, the agent automatically manages the conversation loop:

```elixir
defmodule MyApp.Agents.Assistant do
  use Ash.Resource,
    domain: MyApp.Agents,
    extensions: [AshAgent.Resource]

  agent do
    client "anthropic:claude-3-5-sonnet"
    output MyApp.Reply

    prompt ~p"""
    You are a helpful assistant with access to tools.
    {{ output_format }}
    """

    tools do
      max_iterations 5
      timeout 60_000
      on_error :continue

      tool :get_customer do
        description "Retrieve customer information by ID"
        action {MyApp.Customers.Customer, :read}
        parameters [
          customer_id: [type: :uuid, required: true, description: "The customer's ID"]
        ]
      end

      tool :send_email do
        description "Send an email to a customer"
        function {MyApp.Email, :send, []}
        parameters [
          to: [type: :string, required: true],
          subject: [type: :string, required: true],
          body: [type: :string, required: true]
        ]
      end
    end
  end
end
```

**Tool Configuration Options:**
- `max_iterations` - Maximum number of tool execution iterations (default: 10)
- `timeout` - Timeout in milliseconds for individual tool execution (default: 30_000)
- `on_error` - How to handle tool execution errors: `:continue` (inject error into conversation) or `:halt` (stop execution)

**Tool Types:**
- `action` - Execute an Ash action on a resource
- `function` - Execute an Elixir function (MFA tuple or anonymous function)

## Next Steps

- Read about [AshAgent concepts](../topics/overview.md)
- Explore the DSL reference (auto-generated by Spark)
- Check out example applications

## Learn More

- [Ash Framework Documentation](https://hexdocs.pm/ash)
- [Spark DSL Documentation](https://hexdocs.pm/spark)
